theory AKMA_Plus
/*
Program: AKMA+ (Security and Privacy-Enhanced and Standard-Compatible AKMA for 5G system)
Based on: Authentication and Key Management for Applications (AKMA) based on 3GPP credentials in the 5G System: 3GPP TS 33.535 V18.4.0(2024-07)
Notations: UE: User's Equipment, user of the service, containing UICC and ME
           HN: Home Network, mobile network provider （HN is short for HPLMN, and HPLMN is Home Public Land Mobile Network）
           UDM: Unified Data Management
           AUSF: Authentication Server Function
           AAnF: AKMA Anchor Function
           SUPI: Subscription Permanent Identifier
           A-KID = <A_TID, ~id_HN>: AKMA Key Identifier. Actually, A-KID is globally identifier in Network Access Identifier (NAI) format, 
              i.e., username@realm. The username part includes the Routing Identifier and a temporary UE identifier. The realm part includes HN Identifier.
           AF_ID: Identifier of AF

           CT_UEtoAF: Ciphertext generated by UE, which should be decrypted by AF
           RES_AF: Signature generated by AF, which should be verified by UE
           CT_UEtoAAnF: Ciphertext generated by UE, which should be decrypted by AAnF
           CT_AAnFtoUE: Ciphertext generated by AAnF, which should be decrypted by UE

Protocol: 0.UE --> HN: Primary Authentication(omitted)                                                         //Step 1-2
          1.UE and AUSF generate K_AKMA and A-KID, i.e., <A_TID, ~id_HN> from K_AUSF, UE also generates K_AF.   //Step 3
          2.AUSF --> AAnF: SUPI, <A_TID, ~id_HN>, K_AKMA                                                        //Step 4-5
          3.UE --> AF: A_TID, ~id_HN, CT_UEtoAF, CT_UEtoAAnF                                                    //Step 6
          4.AF --> AAnF: A_TID, ~id_HN, AF_ID, CT_UEtoAAnF                                                      //Step 7
          5.AAnf <--> UDM: A_TID, RoamInfo                                                                      //Step 10-11  (omitted, HN internal transmission)
          6.AAnF generates K_AF from K_AKMA. AAnF also generates CT_AAnFtoUE                                    //Step 12
          7.AAnF --> AF: K_AF, K_AF exptime, CT_AAnFtoUE                                                        //Step 13
          8.AF --> UE: Implict authentication from AF: CT_AAnFtoUE, RES_AF                                      //Step 14
          END

Assumption and Notes: 
1. UE and HN come to an agreement on parameters in KDFs.
2. We suppose the AF is located inside the operator network, while actually AF is communicating with HN through AAnF. 
3. The authentication between UE and HN is primary authentication(like 5G AKA), beyond this protocol.
4. The authentication between HN and AF is beyond the whole content. 
   In 5G AKA, there is a private channel between HN and SN, which is a standard, secure channel abstraction, 
   as previously used in work by Basin, Radomirovic and Schmid: Modeling Human Errors in Security Protocols(CSF 2016).   
   Therefore, we use this abstraction to model the channel between HN and AF.
   Based on TS33.501, mutual authentication between AAnF and AF occurs before running AKMA using the TLS protocol,
   which provides integrity, replay, and confidentiality protection of communication along a private channel.
5. In our work, as AUSF, AAnF(and some functions are omitted like UDM, NEF) are located in HN(Home Network), we supposed 
   the messages translated between AUSF and AAnF is secret.
6. The channel between AF and UE is public channel.

Channels:	AAnF <-> AF  [.<->. is authenticated, confidential, replay protected, order-preserving, binding]

Prepared: K_AUSF between UE and HN, SUPI and K (belong to UE) between UE and HN
*/

begin

heuristic: o "akma_oracle"

builtins: asymmetric-encryption, symmetric-encryption,diffie-hellman, multiset,signing

predicates: Equal(x, y) <=> x = y
            , NotEqual(x, y) <=> not (x = y)

functions: 
KDF_AKMA/3,     // KDF to generate K_AKMA
KDF_A_TID/3,    // KDF to generate <A_TID, ~id_HN>
KDF_AF/2,       // KDF to generate K_AF
KDF_AUSF/3,     // KDF to generate K_AUSF
f/2,            // implicit key confirmation function
MIC/1,           // Message Integrity Code (MIC)
MAC/1,           // MAC UE
MAC_gen/2,      //Message Authentication Code (MAC) generation
MAC_verify/3,    //Message Authentication Code (MAC) verification
Sign_Mac/2

// equations:
// MAC_verify(MAC_gen(k,m),m,k) = true    // MAC Gen and Verify

restriction hn_once:
        " All #i #j. HN_Once()@i & HN_Once()@j ==> #i = #j "

// restriction af_once:
//         " All #i #j. AF_Once()@i & AF_Once()@j ==> #i = #j "

/************************************/
/*         Initialization           */
/************************************/
// Channel between HN and AF
// This is a standard, secure channel abstraction, as previously used in work...
rule send_secure:
	[SndS(~cid,A,B,m)]	// ~cid denotes a channel identifier: should always be a fresh name (possibly created by the attacker)
	-->
	[Sec(~cid,A,B,m)]

rule receive_secure:
	[Sec(~cid,A,B,m)]
	-->
	[RcvS(~cid,A,B,m)]

// rule secureChannel_compromised_in:
// 	[In(<~cid,A,B,x>)]	// attacker can learn cid with secureChannel_compromised_out
// 	--[
// 		Reveal(A,'secureChannel'),
// 		Injected(x)
// 	]->
// 	[Sec(~cid,A,B,x)]

// rule secureChannel_compromised_out:
// 	[Sec(~cid,A,B,m)]
// 	--[Reveal(B,'secureChannel')]->
// 	[Out(<~cid, m>)]

// Initialize a home network    Probably not need, but for completeness
rule Init_HN:
	[Fr(~sk_HN),
	 Fr(~id_HN)]
	--[ HomeNet(~id_HN),
    HN_Once() ]->
	[!HN_key(~id_HN, ~sk_HN),
   !HN(~id_HN),
	 !Pk(~id_HN, pk(~sk_HN)),
	 Out(<~id_HN, pk(~sk_HN)>)]

// Initialize a service provider AF 
// AF_ID = FQDN of the AF || Ua* security protocol identifier, 
// where the Ua* security protocol identifier is specified as Ua security protocol identifier in Annex H of TS 33.220 [4].
/*
rule Init_AF:
  let 
    AF_ID = < 'AF', ~id_AF >
  in
  [Fr(~id_AF)]
  --[ ServicePro(~id_AF) ]->
  [!AF(~id_AF, AF_ID),
   Out(AF_ID)]
*/
rule Init_AF:
  [Fr(~id_AF),
   Fr(~sk_AF)]
  --[ ServicePro(~id_AF)
    // ,AF_Once() 
    ]->
  [
    // !AF(~id_AF),
  //  Out(~id_AF),
   !AF_Ltk(~id_AF, ~sk_AF), 
   !AF_Pk(~id_AF, pk(~sk_AF)), 
   Out(<~id_AF, pk(~sk_AF)>)
 ]

// Initialize Subscription
rule Subscribe_UE:
  [Fr(~SUPI),
   Fr(~K),   
   !HN(~id_HN)]       
  --[ Subscribe(~SUPI, ~id_HN) ]->  //
  [ !Sub(~SUPI, ~id_HN),
  !Sub_K(~SUPI, ~id_HN, ~K) ]


/************************************/
/*          AKMA+  Protocols        */
/************************************/
// Primary Authentication, which is omitted in AKMA+
// Only for the result Key K_AUSF used in AKMA+
rule Init_Pri_Auth:
  let
    K_AUSF = KDF_AUSF(~K, ~id_HN, ~R)
  in
  [Fr(~R),    // a random number in 5G AKA
   !Sub_K(~SUPI, ~id_HN, ~K)]
  --[ Pri_Auth(K_AUSF, ~SUPI, ~id_HN) ]->  
  [ UE_Auth(~SUPI, K_AUSF, ~id_HN),
    AUSF(~SUPI, ~id_HN, K_AUSF) ]


// Key Leakage
// Compromised Subscriptions (SUPI of UE)
rule Reveal_SUPI:
	[!Sub(~SUPI, ~id_HN)]
	--[
		// Security properties
		Reveal(~SUPI, <'SUPI', ~SUPI>),
		Reveal(~id_HN, <'SUPI', ~SUPI>)    // for every component
	]->
	[Out(~SUPI)]

// Compromised Subscriptions (K of UE)
rule Reveal_K:
	[!Sub_K(~SUPI, ~id_HN, ~K)]
	--[
		// Security properties
		Reveal(~SUPI, <'K', ~K>),
		Reveal(~id_HN, <'K', ~K>)    // for every component
	]->
	[Out(~K)]

// Compromised home network (private asymmetric key sk_HN)
rule Reveal_sk_HN:
	[!HN_key(~idHN, ~sk_HN)]
	--[
		// Security properties
		Reveal(~idHN, <'skHN', ~sk_HN>)
	]->
	[Out(~sk_HN)]


// Protocol Rules
// UE: Generate K_AKMA, A-KID
rule AKMA_Material_Generation_UE:
  let
  K_AKMA = KDF_AKMA(K_AUSF, ~SUPI, $C_1)
  A_TID = KDF_A_TID(K_AUSF, ~SUPI, $C_2)
  in
  [ UE_Auth(~SUPI, K_AUSF, ~id_HN) ]
  --[ 
      //Executability
      Generation_UE(~SUPI)
  ]->
  [ UE_Auth_KEY(~SUPI, K_AUSF, K_AKMA, <A_TID, ~id_HN>) ]

// AUSF: Generate K_AKMA, A-KID
rule AKMA_Material_Generation_AUSF:
  let
  K_AKMA = KDF_AKMA(K_AUSF, ~SUPI, $C_1)
  A_TID = KDF_A_TID(K_AUSF, ~SUPI, $C_2)
  in
  [ AUSF(~SUPI, ~id_HN, K_AUSF) ]
  --[ 
      //Executability
      Generation_HN(~id_HN) 
  ]->
  [ AUSF_KEY(~SUPI, K_AUSF, ~id_HN, K_AKMA, <A_TID, ~id_HN>)]

// AUSF --> AAnF: Naanf_AKMA_AnchorKey_Register Request
rule K_AKMA_Register:
  [ AUSF_KEY(~SUPI, K_AUSF, ~id_HN, K_AKMA, <A_TID, ~id_HN>)]
  --[
      //Executability
      K_AKMA_Register(~id_HN)
  ]->
  [ AAnF(~id_HN, ~SUPI, <A_TID, ~id_HN>, K_AKMA) ]

// AAnF deletes the old K_AKMA and <A_TID, ~id_HN>, and then response
// AAnF --> AUSF : Naanf_AKMA_Anchor_Register Response
rule Re_pri_auth:
  [ AAnF1(~id_HN, ~SUPI, <A_TID, ~id_HN>, K_AKMA),
    AUSF_KEY(~SUPI, K_AUSF, ~id_HN, K_AKMA_new, <A_TID_new, ~id_HN>) ]
  --[
      //restriction
      _restrict(NotEqual(K_AKMA_new, K_AKMA)),
      _restrict(NotEqual(A_TID_new, A_TID)),
      //Executability
      K_AKMA_Re_Register(~id_HN)
  ]->
  [ AAnF(~id_HN, ~SUPI, <A_TID_new, ~id_HN>, K_AKMA_new) ]

// UE --> AF: Application Session Establishment Request (Step 6)
rule UE_send_request:
  let
  K_AF = KDF_AF(K_AKMA, ~id_AF)
  U = 'g'^~u
  CT_UEtoAF = aenc(<U,~a1>, PK_AF)
  CT_UEtoAAnF = senc(<~id_AF, ~a2>, K_AKMA)
  in
  [ UE_Auth_KEY(~SUPI, K_AUSF, K_AKMA, <A_TID, ~id_HN>), 
    !AF_Pk(~id_AF, PK_AF),
    Fr(~tid),
    Fr(~u),
    Fr(~a1),
    Fr(~a2),
    !Sub(~SUPI, ~id_HN)
   ]
  --[
      //Executability
      UE_send_request(~SUPI),
      //Security
      Secret(<'A_KID', <A_TID, ~id_HN>>, ~SUPI), 
      Running(<A_TID, ~id_HN>, ~id_AF, <'UE', 'AF', <'A_KID', <A_TID, ~id_HN>>>),
      Running(~SUPI, ~id_HN, <'UE', 'HN', <'A_KID', <A_TID, ~id_HN>>>), 
      Running(<A_TID, ~id_HN>, ~id_AF, <'UE', 'AF', <'K_AF', K_AF>>),
      Running(~SUPI, ~id_HN, <'UE', 'AAnF', <'K_AKMA', K_AKMA>>), 
      Honest(<A_TID, ~id_HN>),
      Honest(~id_AF),
      Honest(~id_HN),
      OutTerm(CT_UEtoAF),
      OutTerm(CT_UEtoAAnF),
      OutTerm2(CT_UEtoAF)
  ]->
  [ Out(<A_TID, ~id_HN, CT_UEtoAF, CT_UEtoAAnF >),
    UE_KEY(~tid, ~SUPI, K_AUSF, K_AKMA, <A_TID, ~id_HN>, K_AF, ~id_AF, ~u, ~a2) ]

// AF --> AAnF: Naanf_AKMA_ApplicationKey_Get_Request (Step 7)
rule AF_send_KeyRequest:
  let
    msg = < A_TID, ~id_HN, ~id_AF, CT_UEtoAAnF >
  in
  [ !AF_Pk(~id_AF, PK_AF),
    In(<A_TID, ~id_HN, CT_UEtoAF, CT_UEtoAAnF >),
    Fr(~cid),
    Fr(~tid)
     ]
  --[
      //Executability
      AF_send_KeyRequest(~id_AF),
      //Security
      Secret(<'A_KID', <A_TID, ~id_HN>>, ~id_AF),
      Commit(~id_AF, <A_TID, ~id_HN>, <'UE', 'AF', <'A_KID', <A_TID, ~id_HN>>>),
      Running(~id_AF, ~id_HN, <'AF', 'HN', <'A_KID', <A_TID, ~id_HN>>>),
      Running(~id_AF, ~id_HN, <'AF', 'HN', <'id_AF', ~id_AF>>),
      Honest(~id_AF),
      Honest(<A_TID, ~id_HN>),
      Honest(~id_HN)
  ]->
  [ SndS(~cid, ~id_AF, ~id_HN, msg), 
    AF_request(~tid, ~id_AF, <A_TID, ~id_HN>, CT_UEtoAF, ~cid)  ]

// AAnF: Generate K_AF
rule K_AF_Generation_AAnF:
  let
    K_AF = KDF_AF(K_AKMA, ~id_AF)
  in
  [ AAnF(~id_HN, ~SUPI, <A_TID, ~id_HN>, K_AKMA),
    !AF_Pk(~id_AF, PK_AF) ]
  --[
        //Executability
        Session_Key_Generation_AAnF(~id_HN)
        
  ]->
  [ AAnF_KEY(~id_HN, ~SUPI, <A_TID, ~id_HN>, K_AKMA, K_AF, ~id_AF),
    AAnF1(~id_HN, ~SUPI, <A_TID, ~id_HN>, K_AKMA) ]

// AAnF --> AF: Naanf_AKMA_Application_Get_Response (Step 11)
rule AAnF_Send_K_AF:
  let
    msg_In_AAnF = < A_TID, ~id_HN, ~id_AF, CT_UEtoAAnF >
    id_AF_2 = fst(sdec(CT_UEtoAAnF,K_AKMA))
    a2 = snd(sdec(CT_UEtoAAnF,K_AKMA))
    a2plus1 = a2 + '1'
    CT_AAnFtoUE = senc(<~id_AF, a2plus1>, K_AKMA)
    session_msg = < K_AF, ~exptime, MAC(<A_TID, ~id_HN>),CT_AAnFtoUE > 
    in
  [ Fr(~exptime),  
    AAnF_KEY(~id_HN, ~SUPI, <A_TID, ~id_HN>, K_AKMA, K_AF, ~id_AF),
    RcvS(~cid, ~id_AF, ~id_HN, msg_In_AAnF)
     ]
  --[ 
      //Executability
      InTerm(CT_UEtoAAnF, a2),
      HN_Response(~id_HN, K_AF),
      // , Eq(mic,MICcode_UEtoAAnF),
      // SendEncrypt(a2, a2plus1),
      //Security
      Secret(<'K_AF', K_AF>, ~id_HN),
      Commit(~id_HN, ~SUPI, <'UE', 'HN', <'A_KID', <A_TID, ~id_HN>>>),
      Commit(~id_HN, ~SUPI, <'UE', 'HN', <'id_AF', id_AF_2>>),
      Commit(~id_HN, ~id_AF, <'AF', 'HN', <'A_KID', <A_TID, ~id_HN>>>),
      Commit(~id_HN, ~id_AF, <'AF', 'AAnF', <'K_AKMA', K_AKMA>>),
      Running(~id_HN, ~id_AF, <'HN', 'AF', <'K_AF', K_AF>>),
      Running(~id_HN, ~id_AF, <'HN', 'AF', <'K_AF_exptime', ~exptime>>),
      Running(~id_HN, ~SUPI, <'AAnF', 'UE', <'K_AKMA', K_AKMA>>),
      Honest(~id_HN),
      Honest(~id_AF),
      Eq(~id_AF, id_AF_2)
  ]->
  [ SndS(~cid, ~id_HN, ~id_AF, session_msg) ]

// Application Session Establishment Response
// AF --> UE: for impliclit authentication
rule AF_Response_Key:
  let
    confmess1 = f(K_AF, 'AF')
    msg_IN = < K_AF, ~exptime, MAC(<A_TID, ~id_HN>), CT_AAnFtoUE >
    U = fst(adec(CT_UEtoAF, ~AF_RSA))   
    a1 = snd(adec(CT_UEtoAF, ~AF_RSA))
    V = 'g'^~v
    Ks=U^~v
    K_AF_prime = KDF_AF(K_AF,Ks)
    Sign_Mac_Value = Sign_Mac(V, a1)
    RES_AF = sign(Sign_Mac_Value, ~AF_RSA)
    
  in
  [ RcvS(~cid, ~id_HN, ~id_AF, msg_IN), 
    AF_request(~tid, ~id_AF, <A_TID, ~id_HN>, CT_UEtoAF, ~cid),
    Fr(~v),
    !AF_Ltk(~id_AF, ~AF_RSA)
  ]
  --[
      // OutTerm(CT_AFtoUE),
      //add at the second time
      InTerm2(CT_UEtoAF, a1),  
    //Executability
      AF_session_response(~id_AF, K_AF),
      Forward_Secrecy(~tid, K_AF_prime),
      // , Eq(mic,MICcode_UEtoAF),
      //Security
      Secret(<'K_AF', K_AF>, ~id_AF),
      Secret(<'K_AF_prime', K_AF_prime>, ~id_AF),
      Commit(~id_AF, <A_TID, ~id_HN>, <'UE', 'AF', <'K_AF', K_AF>>),
      Commit(~id_AF, ~id_HN, <'HN', 'AF', <'K_AF', K_AF>>),
      Commit(~id_AF, ~id_HN, <'HN', 'AF', <'K_AF_exptime', ~exptime>>),
      Honest(~id_AF),
      Honest(~id_HN),
      Honest(<A_TID, ~id_HN>)
  ]->
  [ Out(<confmess1, CT_AAnFtoUE, RES_AF, V, Sign_Mac_Value>),
    AF_Confirmation(~tid, ~id_AF, K_AF, <A_TID, ~id_HN>, ~cid) ]

// implicit key confirmation
// UE --> AF: UE receives key confirmation from AF
rule UE_Key_Confirmation:
  let
    confmess2 = f(K_AF, 'UE')
    a2plus1 = ~a2 + '1'
    a2plus1_2 = snd(sdec(CT_AAnFtoUE, K_AKMA))
    Ks=V^~u
    K_AF_prime = KDF_AF(K_AF,Ks)
  in
  [ In(<f(K_AF, 'AF'), CT_AAnFtoUE, RES_AF, V, Sign_Mac_Value>),
  !AF_Pk(~id_AF,PK_AF),
    UE_KEY(~tid, ~SUPI, K_AUSF, K_AKMA, <A_TID, ~id_HN>, K_AF, ~id_AF, ~u, ~a2)
   ]
  --[
      //Security
      //Secret(<'K_AF', K_AF>, ~SUPI),
      Secret(<'K_AF_prime', K_AF_prime>, ~SUPI),
      Commit(~SUPI, ~id_HN, <'AAnF', 'UE', <'K_AKMA', K_AKMA>>),
      Confirmation(<'UE', ~SUPI>, <'AF', ~id_AF>, <'UE', 'AF', <'K_AF', K_AF>>),
      Honest(~id_AF),
      Honest(~SUPI),
      Honest(~id_HN),
      //Executability
      UE_Key_Confirmation(~SUPI, K_AF),
      Eq(verify(RES_AF, Sign_Mac_Value, PK_AF), true),
      Eq(a2plus1, a2plus1_2)
  ]->
  [ ]



/************************************/
/*       Execution Properties       */
/************************************/


lemma Protocol_executable_without_Reprimary:
    exists-trace
    "Ex A B C m #i1 #i2 #i3 #i6 #i7 #i8 #i9 #i10. (Generation_UE(A) @i1 &
                                                               Generation_HN(B) @i2 &
                                                               K_AKMA_Register(B) @i3 &
                                                               UE_send_request(A) @i6 &
                                                               AF_send_KeyRequest(C) @i7 &
                                                               HN_Response(B, m) @i8 &
                                                               AF_session_response(C, m) @i9 &
                                                               UE_Key_Confirmation(A, m) @i10)
  
    "

// // Secrecy of K_AF_prime
lemma secure_K_AF_prime:
    all-traces
    " All n A #i. Secret(<'K_AF_prime', n>, A) @i 
      ==>(not (Ex #j. K(n)@j )) | (Ex X data #r. Reveal(X, data) @r & Honest(X)@i) 
         "

// Secrecy of SUPI
lemma secure_SUPI:
    all-traces
    " All n A #i. Secret(<'SUPI', n>, A) @i 
      ==>(not (Ex #j. K(n)@j )) | (Ex X data #r. Reveal(X, data) @r & Honest(X)@i) 
         "

lemma Forward_Secrecy:
    all-traces
    "
        All t1 A #i. Forward_Secrecy(t1, A)@i
        ==> (not (Ex #j. KU(A) @j)) | (Ex P data #r. Reveal(P, data)@r & r < i & Honest(P)@i)
    "

lemma mutual_authentication_UE_AAnF_one_direction:
    all-traces
    "All A B t #i1. (Commit(A, B, <'UE', 'AAnF', <'K_AKMA', t>>) @i1)
    ==> (Ex #j1. Running(B, A, <'UE', 'AAnF', <'K_AKMA', t>>) @j1)
      | (Ex D m #l. Reveal(D, m) @l & Honest(D) @i1 )
    "
  
lemma mutual_authentication_UE_AAnF_other_direction:
    all-traces
    "All A B t #i2. (Commit(B, A, <'AAnF', 'UE', <'K_AKMA', t>>) @i2)
    ==> (Ex #j2. Running(A, B, <'AAnF', 'UE', <'K_AKMA', t>>) @j2)
        | (Ex D m #l. Reveal(D, m) @l & Honest(D) @i2 )
    "
end
